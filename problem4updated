#@Author Kimberly Nguyen
import sys
import heapq
from database import create_db, reset_db, get_islands_data, get_experiences_data

class Graph:
    def __init__(self):
        self.adjacency_list = {}

    def add_edge(self, from_island, to_island, weight):
        if from_island not in self.adjacency_list:
            self.adjacency_list[from_island] = []
        self.adjacency_list[from_island].append((to_island, weight))
        
    def get_neighbors(self, island):
        return self.adjacency_list.get(island, [])

def dijkstra(graph, experiences, start):
    queue = [(0, start, set())] 
    visited = {}
    best_experiences = {}
    #Stores the path taken to reach each island
    paths = {start: []}  

    while queue:
        total_time, current, exp_total = heapq.heappop(queue)

        if current in visited and visited[current] <= total_time:
            continue
        visited[current] = total_time
        
        #Update the best experiences for the current island
        best_experiences[current] = exp_total

        #Creates new experience
        current_experiences = experiences.get(current, set())
        new_experiences = exp_total.union(current_experiences)

        for neighbor, travel_time in graph.get_neighbors(current):
            new_time = total_time + travel_time
            
            #Updates if a shorter path is found
            if neighbor not in visited or new_time < visited[neighbor]:
                heapq.heappush(queue, (new_time, neighbor, new_experiences))
                paths[neighbor] = paths[current] + [current]

    return visited, best_experiences, paths

def display_exp(island_id, island_name, distance = 0):
    #Gets experiences for the island from ID
    experiences = get_experiences_data(island_id)
    if experiences:
        print(f"Experiences on {island_name} (Travel time: {distance} hours):")
        for index, (exp_name, exp_duration) in enumerate(experiences):
            print(f"    {index + 1}. {exp_name}: {exp_duration} hour(s)")
    else:
        print(f"No experiences available on {island_name} (Travel time: {distance} hours)")
    print()

def find_optimal_experience(distances, experiences_collected, paths):
    optimal_island = None
    max_experiences = 0
    min_time = sys.maxsize

    for island, time in distances.items():
        experience_count = len(experiences_collected.get(island, set()))
        # Check for the optimal experience collection criteria
        if (experience_count > max_experiences) or (experience_count == max_experiences and time < min_time):
            max_experiences = experience_count
            min_time = time
            optimal_island = island
            
    return optimal_island, max_experiences, min_time, paths[optimal_island] + [optimal_island] if optimal_island else []

def display_islands(islands):
    print("Here is a list of islands: ")
    for index, island in enumerate(islands):
        print(f"  Island #{index + 1}: {island['name']}")
    print()

def main():
    create_db() 
    reset_db()
    island_data_list = get_islands_data()
    graph = Graph()
    #print(f"Resources on {island['name']}:")
    
    #valid paths for each island
    paths = {
        'Hawaii': {'Samoa', 'Tonga', 'New Zealand', 'American Samoa'},
        'Samoa': {'Hawaii', 'Tonga', 'American Samoa', 'New Zealand', 'Tuvalu', 'Tokelau', 'Rotuma'},
        'Tonga': {'Hawaii', 'Samoa', 'New Zealand', 'Rapanui', 'Wallis and Futuna', 'French Polynesia'},
        'American Samoa': {'Hawaii', 'Samoa'},
        'New Zealand': {'Hawaii', 'Samoa', 'Tonga', 'Cook Islands', 'Niue', 'Norfolk Island'},
        'Rapanui': {'Tonga', 'Pitcairn Islands', 'Easter Island'},
        'Cook Islands': {'New Zealand', 'Niue', 'French Polynesia'},
        'Easter Island': {'Rapanui', 'Pitcairn Islands'},
        'French Polynesia': {'Tonga', 'Cook Islands'},
        'Niue': {'New Zealand', 'Cook Islands'},
        'Norfolk Island': {'New Zealand'},
        'Pitcairn Islands': {'Rapanui', 'Easter Island'},
        'Rotuma': {'Fiji', 'Samoa'},
        'Tokelau': {'Samoa'},
        'Tuvalu': {'Samoa'},
        'Wallis and Futuna': {'Tonga'}
    }

    #Sample experiences with weights
    exps = [
        ('Hawaii', 'Samoa', 1),
        ('Hawaii', 'Tonga', 2),
        ('Hawaii', 'New Zealand', 3),
        ('Rapanui', 'Tonga', 4),
        ('New Zealand', 'Samoa', 2),
        ('New Zealand', 'Tonga', 2),
        ('Samoa', 'Tonga', 1),
        ('Tonga', 'Rapanui', 4),
    ]

    for from_island, to_island, weight in exps:
        graph.add_edge(from_island, to_island, weight)
        graph.add_edge(to_island, from_island, weight)

    #shows islands
    display_islands(island_data_list)

    #User input for starting island
    try:
        starting_island = input("Where would you like to travel to first? ")
        
        #Run Dijkstra's algorithm
        distances, experiences_collected, paths = dijkstra(graph, paths, starting_island)
        
        #Find optimal area to travel to maximize experiences in the least time
        optimal_island, max_experiences, min_time, optimal_path = find_optimal_experience(distances, experiences_collected, paths)
        
        #Shows the path taken
        if optimal_island:
            print(f"The optimal area to travel to for the most experiences in the least amount of time is {optimal_island}.")
            print(f"You can gain {max_experiences} experiences in {min_time} hour(s).")
            print("The path taken to reach this destination is:")
            print(" -> ".join(optimal_path)) 

            for island_name in optimal_path:
                # Find island data by name
                island = next((item for item in island_data_list if item['name'] == island_name), None)
                if island:
                    # Get travel distance
                    distance = distances[island_name]
                    display_exp(island['id'], island_name, distance)

    except KeyError:
        print("Error! The island you entered does not exist.")
    except Exception as e:
        print(f"An error occurred: {e}")

if __name__ == "__main__":
    main()
